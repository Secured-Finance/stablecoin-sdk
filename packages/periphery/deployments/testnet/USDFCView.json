{
  "address": "0xE7e2b154cB360D5Ab258700D51d5f62990A5d71C",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_troveManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_sortedTroves",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "SortedTroves",
      "outputs": [
        {
          "internalType": "contract ISortedTroves",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "TroveManager",
      "outputs": [
        {
          "internalType": "contract ITroveManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_of",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_acc",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_iterations",
          "type": "uint256"
        }
      ],
      "name": "getDebtInFront",
      "outputs": [
        {
          "internalType": "address",
          "name": "next",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "debt",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x6e97aae45268a0fbe24185cf1bf180e891fa9434a4bf7115984eaa36a1eb7e27",
  "receipt": {
    "to": null,
    "from": "0xDBA767F3DFF3835BEf5dE1eDEe91A9901402AB21",
    "contractAddress": "0xE7e2b154cB360D5Ab258700D51d5f62990A5d71C",
    "transactionIndex": 0,
    "gasUsed": "46532286",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc425d4f58413c92615887ec76f4f478b3cce2c720874fe8a9cb9bc2da0336313",
    "transactionHash": "0x6e97aae45268a0fbe24185cf1bf180e891fa9434a4bf7115984eaa36a1eb7e27",
    "logs": [],
    "blockNumber": 2526826,
    "cumulativeGasUsed": "0",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5719459B37bB156BFa54dfE997D0286062DCcC36",
    "0xB7ee07b4a2A6F02941C6682DF2754389cfDdde03"
  ],
  "numDeployments": 1,
  "solcInputHash": "a75545a951a38cfe44fb5cd4c7742549",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sortedTroves\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TroveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_iterations\",\"type\":\"uint256\"}],\"name\":\"getDebtInFront\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getDebtInFront(address,uint256,uint256)\":{\"params\":{\"_acc\":\"Accumulated sum used in subsequent calls, 0 for first call\",\"_iterations\":\"Maximum number of troves to traverse\",\"_of\":\"Address of the trove owner\"},\"returns\":{\"debt\":\"Accumulated debt to be used in the subsequent call\",\"next\":\"Trove owner address to be used in the subsequent call, address(0) at the end of list\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getDebtInFront(address,uint256,uint256)\":{\"notice\":\"Returns the debt in front of the users trove in the sorted list\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/USDFCView.sol\":\"USDFCView\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@secured-finance/stablecoin-contracts/contracts/Dependencies/OpenZeppelin/interfaces/IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n *\\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     *\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to\\n     * a value in the near future. The deadline argument can be set to uint(-1) to\\n     * create Permits that effectively never expire.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n    function permitTypeHash() external view returns (bytes32);\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb97778253e8bad91f94e6bccac200336cff2740856586f0cfe4664a76b582735\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Dependencies/OpenZeppelin/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * Based on the OpenZeppelin IER20:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.2/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x6bb3f7465d2da11ac3db366cbec5aba488db168c6b75a47acbe67cbdcbacec51\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Dependencies/OpenZeppelin/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * Based on the OpenZeppelin IERC20Metadata:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/extensions/IERC20Metadata.sol\\n *\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xcf079cc0ab39bbb820284f8acba755b8252e20c39a6a5e5df564cf79bf6e3059\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/ICollSurplusPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface ICollSurplusPool {\\n    // --- Events ---\\n\\n    event CollSurplusPoolFILBalanceUpdated(uint _newBalance);\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n\\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\\n    event FILSent(address _to, uint _amount);\\n\\n    // --- Contract setters ---\\n\\n    function getFIL() external view returns (uint);\\n\\n    function getCollateral(address _account) external view returns (uint);\\n\\n    function accountSurplus(address _account, uint _amount) external;\\n\\n    function claimColl(address _account) external;\\n}\\n\",\"keccak256\":\"0x52b9b7c981cc417003dc5b68a6c1899654db0a548307dfba34f014cb8e5f6f93\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/IDebtToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../Dependencies/OpenZeppelin/interfaces/IERC2612.sol\\\";\\nimport \\\"../Dependencies/OpenZeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IDebtToken is IERC20Metadata, IERC2612 {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n\\n    // --- Functions ---\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n\\n    function sendToPool(address _sender, address poolAddress, uint256 _amount) external;\\n\\n    function returnFromPool(address poolAddress, address user, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0xcd901e05dc595b8d24eedfae348c81adb19d90727fa6db7319d24812b2fd1580\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/IPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\ninterface IPriceFeed {\\n    // --- Events ---\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n    event PriceFeedStatusChanged(Status newStatus);\\n\\n    enum Status {\\n        chainlinkWorking,\\n        usingTellorChainlinkUntrusted,\\n        bothOraclesUntrusted,\\n        usingTellorChainlinkFrozen,\\n        usingChainlinkTellorUntrusted\\n    }\\n\\n    // --- Function ---\\n    function fetchPrice() external returns (uint);\\n}\\n\",\"keccak256\":\"0x777e4e944424419905e66a59c9d1a4cfde9c008d4f59457a69148ec058f0f424\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/IProtocolToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../Dependencies/OpenZeppelin/interfaces/IERC2612.sol\\\";\\nimport \\\"../Dependencies/OpenZeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IProtocolToken is IERC20Metadata, IERC2612 {\\n    // --- Events --\\n\\n    event AnnualAllocationRateUpdated(uint _annualAllocationRate);\\n    event AnnualAllocationRecipientUpdated(address _annualAllocationRecipient);\\n\\n    // --- Functions ---\\n\\n    function sendToProtocolTokenStaking(address _sender, uint256 _amount) external;\\n\\n    function getAllocationStartTime() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x3ad6cb8c63a5cb328b6cd5514664a2a127c83b6bdf0eaf4391143f64acd2d5d0\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/IProtocolTokenStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./IProtocolToken.sol\\\";\\nimport \\\"./IDebtToken.sol\\\";\\n\\ninterface IProtocolTokenStaking {\\n    // --- Events --\\n\\n    event ProtocolTokenAddressChanged(address _protocolTokenAddress);\\n    event DebtTokenAddressChanged(address _debtTokenAddress);\\n    event TroveManagerAddressChanged(address _troveManager);\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n\\n    event StakeChanged(address indexed staker, uint newStake);\\n    event StakingGainsWithdrawn(address indexed staker, uint debtTokenGain, uint FILGain);\\n    event F_FILUpdated(uint _F_FIL);\\n    event F_DebtTokenUpdated(uint _F_DebtToken);\\n    event TotalProtocolTokenStakedUpdated(uint _totalProtocolTokenStaked);\\n    event FILSent(address _account, uint _amount);\\n    event StakerSnapshotsUpdated(address _staker, uint _F_FIL, uint _F_DebtToken);\\n\\n    event UnallocatedFILUpdated(uint _unallocatedFIL);\\n    event UnallocatedDebtTokenUpdated(uint _unallocatedDebtToken);\\n\\n    // --- Functions ---\\n\\n    function protocolToken() external view returns (IProtocolToken);\\n    function debtToken() external view returns (IDebtToken);\\n\\n    function stake(uint _tokenAmount) external;\\n\\n    function unstake(uint _tokenAmount) external;\\n\\n    function increaseF_FIL(uint _FILFee) external;\\n\\n    function increaseF_DebtToken(uint _debtTokenFee) external;\\n\\n    function getPendingFILGain(address _user) external view returns (uint);\\n\\n    function getPendingDebtTokenGain(address _user) external view returns (uint);\\n}\\n\",\"keccak256\":\"0xc6a1ed703cb80f03151a0a5094625c78265ea4687c05e5fa4fab4ec58d13205f\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/ISortedTroves.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n// Common interface for the SortedTroves Doubly Linked List.\\ninterface ISortedTroves {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\n    event NodeAdded(address _id, uint _NICR);\\n    event NodeRemoved(address _id);\\n\\n    // --- Functions ---\\n\\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\\n\\n    function remove(address _id) external;\\n\\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\\n\\n    function contains(address _id) external view returns (bool);\\n\\n    function isFull() external view returns (bool);\\n\\n    function isEmpty() external view returns (bool);\\n\\n    function getSize() external view returns (uint256);\\n\\n    function getMaxSize() external view returns (uint256);\\n\\n    function getFirst() external view returns (address);\\n\\n    function getLast() external view returns (address);\\n\\n    function getNext(address _id) external view returns (address);\\n\\n    function getPrev(address _id) external view returns (address);\\n\\n    function validInsertPosition(\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external view returns (bool);\\n\\n    function findInsertPosition(\\n        uint256 _ICR,\\n        address _prevId,\\n        address _nextId\\n    ) external view returns (address, address);\\n}\\n\",\"keccak256\":\"0xae444d2fc17603ef40ef316b0b666bf6da466e289b217ca77bbfbed89a2903f4\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/IStabilityPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/*\\n * The Stability Pool holds debt tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its debt gets offset with\\n * debt tokens in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of debt tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a debt token loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an FIL gain, as the FIL collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total debt token in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / FIL gain derivations:\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n * --- PROTOCOL TOKEN ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * An ProtocolToken issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued ProtocolToken in proportion to the deposit as a share of total deposits. The ProtocolToken earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * Please see the system Readme for an overview:\\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\\n */\\ninterface IStabilityPool {\\n    // --- Events ---\\n\\n    event StabilityPoolFILBalanceUpdated(uint _newBalance);\\n    event StabilityPoolDebtTokenBalanceUpdated(uint _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DebtTokenAddressChanged(address _newDebtTokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n\\n    event P_Updated(uint _P);\\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\\n    event EpochUpdated(uint128 _currentEpoch);\\n    event ScaleUpdated(uint128 _currentScale);\\n\\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\\n\\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\\n    event FrontEndStakeChanged(\\n        address indexed _frontEnd,\\n        uint _newFrontEndStake,\\n        address _depositor\\n    );\\n\\n    event FILGainWithdrawn(address indexed _depositor, uint _FIL, uint _debtTokenLoss);\\n    event ProtocolTokenPaidToDepositor(address indexed _depositor, uint _protocolToken);\\n    event ProtocolTokenPaidToFrontEnd(address indexed _frontEnd, uint _protocolToken);\\n    event FILSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n\\n    /*\\n     * Initial checks:\\n     * - Frontend is registered or zero address\\n     * - Sender is not a registered frontend\\n     * - _amount is not zero\\n     * ---\\n     * - Triggers a ProtocolToken issuance, based on time passed since the last issuance. The ProtocolToken issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (ProtocolToken, FIL) to depositor\\n     * - Sends the tagged front end's accumulated ProtocolToken gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint _amount, address _frontEndTag) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is zero or there are no under collateralized troves left in the system\\n     * - User has a non zero deposit\\n     * ---\\n     * - Triggers a ProtocolToken issuance, based on time passed since the last issuance. The ProtocolToken issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (ProtocolToken, FIL) to depositor\\n     * - Sends the tagged front end's accumulated ProtocolToken gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint _amount) external;\\n\\n    /*\\n     * Initial checks:\\n     * - User has a non zero deposit\\n     * - User has an open trove\\n     * - User has some FIL gain\\n     * ---\\n     * - Triggers a ProtocolToken issuance, based on time passed since the last issuance. The ProtocolToken issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's ProtocolToken gain to  depositor\\n     * - Sends all tagged front end's ProtocolToken gain to the tagged front end\\n     * - Transfers the depositor's entire FIL gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake\\n     */\\n    function withdrawFILGainToTrove(address _upperHint, address _lowerHint) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Frontend (sender) not already registered\\n     * - User (sender) has no deposit\\n     * - _kickbackRate is in the range [0, 100%]\\n     * ---\\n     * Front end makes a one-time selection of kickback rate upon registering\\n     */\\n    function registerFrontEnd(uint _kickbackRate) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Caller is TroveManager\\n     * ---\\n     * Cancels out the specified debt against the debt token contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's FIL collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint _debt, uint _coll) external;\\n\\n    /*\\n     * Returns the total amount of FIL held by the pool, accounted in an internal variable instead of `balance`,\\n     * to exclude edge cases like FIL received from a self-destruct.\\n     */\\n    function getFIL() external view returns (uint);\\n\\n    /*\\n     * Returns debt token held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n     */\\n    function getTotalDebtTokenDeposits() external view returns (uint);\\n\\n    /*\\n     * Calculates the FIL gain earned by the deposit since its last snapshots were taken.\\n     */\\n    function getDepositorFILGain(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Calculate the ProtocolToken gain earned by a deposit since its last snapshots were taken.\\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\\n     * which they made their deposit.\\n     */\\n    function getDepositorProtocolTokenGain(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Return the ProtocolToken gain earned by the front end.\\n     */\\n    function getFrontEndProtocolTokenGain(address _frontEnd) external view returns (uint);\\n\\n    /*\\n     * Return the user's compounded deposit.\\n     */\\n    function getCompoundedDebtTokenDeposit(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Return the front end's compounded stake.\\n     *\\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\\n     */\\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\\n\\n    /*\\n     * Fallback function\\n     * Only callable by Active Pool, it just accounts for FIL received\\n     * receive() external payable;\\n     */\\n}\\n\",\"keccak256\":\"0xe1b951710da93cbf81e49b4f618fa79a75660a3aa0ad743e78fa23e36c74dbf4\",\"license\":\"MIT\"},\"@secured-finance/stablecoin-contracts/contracts/Interfaces/ITroveManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./ICollSurplusPool.sol\\\";\\nimport \\\"./IDebtToken.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\nimport \\\"./IProtocolTokenStaking.sol\\\";\\nimport \\\"./ISortedTroves.sol\\\";\\nimport \\\"./IStabilityPool.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface ITroveManager {\\n    // --- Events ---\\n\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event DebtTokenAddressChanged(address _newDebtTokenAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event ProtocolTokenStakingAddressChanged(address _protocolTokenStakingAddress);\\n\\n    event Liquidation(\\n        uint _liquidatedDebt,\\n        uint _liquidatedColl,\\n        uint _collGasCompensation,\\n        uint _debtGasCompensation\\n    );\\n    event Redemption(\\n        uint _attemptedDebtTokenAmount,\\n        uint _actualDebtTokenAmount,\\n        uint _FILSent,\\n        uint _FILFee\\n    );\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint stake,\\n        TroveManagerOperation _operation\\n    );\\n    event TroveLiquidated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        TroveManagerOperation _operation\\n    );\\n    event BaseRateUpdated(uint _baseRate);\\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\\n    event TotalStakesUpdated(uint _newTotalStakes);\\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\\n    event LTermsUpdated(uint _L_FIL, uint _L_Debt);\\n    event TroveSnapshotsUpdated(uint _L_FIL, uint _L_Debt);\\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\\n\\n    enum Status {\\n        nonExistent,\\n        active,\\n        closedByOwner,\\n        closedByLiquidation,\\n        closedByRedemption\\n    }\\n\\n    enum TroveManagerOperation {\\n        applyPendingRewards,\\n        liquidateInNormalMode,\\n        liquidateInRecoveryMode,\\n        redeemCollateral\\n    }\\n\\n    // --- Functions ---\\n\\n    function collSurplusPool() external view returns (ICollSurplusPool);\\n    function stabilityPool() external view returns (IStabilityPool);\\n    function debtToken() external view returns (IDebtToken);\\n    function priceFeed() external view returns (IPriceFeed);\\n    function protocolTokenStaking() external view returns (IProtocolTokenStaking);\\n    function sortedTroves() external view returns (ISortedTroves);\\n\\n    function Troves(address _borrower) external view returns (uint, uint, uint, Status, uint128);\\n    function rewardSnapshots(address _borrower) external view returns (uint, uint);\\n\\n    function getTroveOwnersCount() external view returns (uint);\\n\\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\\n\\n    function getNominalICR(address _borrower) external view returns (uint);\\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\\n\\n    function liquidate(address _borrower) external;\\n\\n    function liquidateTroves(uint _n) external;\\n\\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\\n\\n    function redeemCollateral(\\n        uint _debtTokenAmount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR,\\n        uint _maxIterations,\\n        uint _maxFee\\n    ) external;\\n\\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\\n\\n    function updateTroveRewardSnapshots(address _borrower) external;\\n\\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\\n\\n    function applyPendingRewards(address _borrower) external;\\n\\n    function getPendingFILReward(address _borrower) external view returns (uint);\\n\\n    function getPendingDebtReward(address _borrower) external view returns (uint);\\n\\n    function hasPendingRewards(address _borrower) external view returns (bool);\\n\\n    function getEntireDebtAndColl(\\n        address _borrower\\n    ) external view returns (uint debt, uint coll, uint pendingDebtReward, uint pendingFILReward);\\n\\n    function closeTrove(address _borrower) external;\\n\\n    function removeStake(address _borrower) external;\\n\\n    function getRedemptionRate() external view returns (uint);\\n    function getRedemptionRateWithDecay() external view returns (uint);\\n\\n    function getRedemptionFeeWithDecay(uint _FILDrawn) external view returns (uint);\\n\\n    function getBorrowingRate() external view returns (uint);\\n    function getBorrowingRateWithDecay() external view returns (uint);\\n\\n    function getBorrowingFee(uint _debt) external view returns (uint);\\n    function getBorrowingFeeWithDecay(uint _debt) external view returns (uint);\\n\\n    function decayBaseRateFromBorrowing() external;\\n\\n    function getTroveStatus(address _borrower) external view returns (uint);\\n\\n    function getTroveStake(address _borrower) external view returns (uint);\\n\\n    function getTroveDebt(address _borrower) external view returns (uint);\\n\\n    function getTroveColl(address _borrower) external view returns (uint);\\n\\n    function setTroveStatus(address _borrower, uint num) external;\\n\\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\\n\\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint);\\n\\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint);\\n\\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint);\\n\\n    function getTCR(uint _price) external view returns (uint);\\n\\n    function checkRecoveryMode(uint _price) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf4fda75cd1520668fabdacf25ac124044a7b4a3cd97ea975a3dd58f33cb3a39a\",\"license\":\"MIT\"},\"contracts/USDFCView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport {ITroveManager} from \\\"@secured-finance/stablecoin-contracts/contracts/Interfaces/ITroveManager.sol\\\";\\nimport {ISortedTroves} from \\\"@secured-finance/stablecoin-contracts/contracts/Interfaces/ISortedTroves.sol\\\";\\n\\ncontract USDFCView {\\n    ITroveManager public TroveManager;\\n    ISortedTroves public SortedTroves;\\n\\n    constructor(address _troveManager, address _sortedTroves) {\\n        TroveManager = ITroveManager(_troveManager);\\n        SortedTroves = ISortedTroves(_sortedTroves);\\n    }\\n\\n    /// @notice Returns the debt in front of the users trove in the sorted list\\n    /// @param _of Address of the trove owner\\n    /// @param _acc Accumulated sum used in subsequent calls, 0 for first call\\n    /// @param _iterations Maximum number of troves to traverse\\n    /// @return next Trove owner address to be used in the subsequent call, address(0) at the end of list\\n    /// @return debt Accumulated debt to be used in the subsequent call\\n    function getDebtInFront(\\n        address _of,\\n        uint256 _acc,\\n        uint256 _iterations\\n    ) external view returns (address next, uint256 debt) {\\n        next = _of;\\n        debt = _acc;\\n        for (uint256 i = 0; i < _iterations && next != address(0); i++) {\\n            next = SortedTroves.getNext(next);\\n            debt = debt + TroveManager.getTroveDebt(next);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7257335e40900345bc7fe0c0ec3fdbb3abfd320812291da1973708c1dd124fb3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506040516102c03803806102c08339818101604052604081101561003357600080fd5b508051602090910151600080546001600160a01b039384166001600160a01b031991821617909155600180549390921692169190911790556102468061007a6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806369a0281814610046578063b15c40001461006a578063c3d2af6914610072575b600080fd5b61004e6100c7565b604080516001600160a01b039092168252519081900360200190f35b61004e6100d6565b6100a46004803603606081101561008857600080fd5b506001600160a01b0381351690602081013590604001356100e5565b604080516001600160a01b03909316835260208301919091528051918290030190f35b6000546001600160a01b031681565b6001546001600160a01b031681565b828260005b838110801561010157506001600160a01b03831615155b15610207576001546040805163765e015960e01b81526001600160a01b0386811660048301529151919092169163765e0159916024808301926020929190829003018186803b15801561015357600080fd5b505afa158015610167573d6000803e3d6000fd5b505050506040513d602081101561017d57600080fd5b50516000546040805163d66a255360e01b81526001600160a01b038085166004830152915193965091169163d66a255391602480820192602092909190829003018186803b1580156101ce57600080fd5b505afa1580156101e2573d6000803e3d6000fd5b505050506040513d60208110156101f857600080fd5b505191909101906001016100ea565b5093509391505056fea2646970667358221220507a3734fe775ca91f6d0e933a62bfd215e7dab197163fe7092a46311cae136564736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806369a0281814610046578063b15c40001461006a578063c3d2af6914610072575b600080fd5b61004e6100c7565b604080516001600160a01b039092168252519081900360200190f35b61004e6100d6565b6100a46004803603606081101561008857600080fd5b506001600160a01b0381351690602081013590604001356100e5565b604080516001600160a01b03909316835260208301919091528051918290030190f35b6000546001600160a01b031681565b6001546001600160a01b031681565b828260005b838110801561010157506001600160a01b03831615155b15610207576001546040805163765e015960e01b81526001600160a01b0386811660048301529151919092169163765e0159916024808301926020929190829003018186803b15801561015357600080fd5b505afa158015610167573d6000803e3d6000fd5b505050506040513d602081101561017d57600080fd5b50516000546040805163d66a255360e01b81526001600160a01b038085166004830152915193965091169163d66a255391602480820192602092909190829003018186803b1580156101ce57600080fd5b505afa1580156101e2573d6000803e3d6000fd5b505050506040513d60208110156101f857600080fd5b505191909101906001016100ea565b5093509391505056fea2646970667358221220507a3734fe775ca91f6d0e933a62bfd215e7dab197163fe7092a46311cae136564736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getDebtInFront(address,uint256,uint256)": {
        "params": {
          "_acc": "Accumulated sum used in subsequent calls, 0 for first call",
          "_iterations": "Maximum number of troves to traverse",
          "_of": "Address of the trove owner"
        },
        "returns": {
          "debt": "Accumulated debt to be used in the subsequent call",
          "next": "Trove owner address to be used in the subsequent call, address(0) at the end of list"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getDebtInFront(address,uint256,uint256)": {
        "notice": "Returns the debt in front of the users trove in the sorted list"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1209,
        "contract": "contracts/USDFCView.sol:USDFCView",
        "label": "TroveManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(ITroveManager)1201"
      },
      {
        "astId": 1211,
        "contract": "contracts/USDFCView.sol:USDFCView",
        "label": "SortedTroves",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ISortedTroves)546"
      }
    ],
    "types": {
      "t_contract(ISortedTroves)546": {
        "encoding": "inplace",
        "label": "contract ISortedTroves",
        "numberOfBytes": "20"
      },
      "t_contract(ITroveManager)1201": {
        "encoding": "inplace",
        "label": "contract ITroveManager",
        "numberOfBytes": "20"
      }
    }
  }
}